"""
Module Description:
    Contains functions needed to calculate the thermal energy stored and thermal
    energy dispatched by the thermal energy storage (TES) system
"""

from lfd_package.modules.__init__ import ureg, Q_


def calc_excess_and_deficit_chp_heat_gen(chp_gen_hourly_btuh=None, load_following_type=None, class_dict=None):
    """
    Calculates excess heat generated by the CHP unit each hour (positive values) and
    the difference between the heat generated by the CHP unit and the heat needed
    to meet demand (negative values).

    Function is used in the calc_tes_heat_flow_and_soc function

    Parameters
    ---------
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py).
    chp_gen_hourly_btuh: list
        contains hourly chp heat generated in Btu/hr.
    load_following_type: string
        specifies whether calculation is for electrical load following (ELF) state
        or thermal load following (TLF) state.

    Returns
    -------
    excess_heat: list (Quantity)
        Excess heat generated by CHP each hour (positive) and additional heat needed
        (negative). All items have units of Btu/hour.
    """
    args_list = [chp_gen_hourly_btuh, load_following_type, class_dict]
    if any(elem is None for elem in args_list) is False:
        heat_demand = class_dict['demand'].hl

        if load_following_type == "TLF":
            raise Exception("Use tlf_calc_hourly_heat_generated function from chp.py")  # TODO: Fix this
        else:
            excess_heat = []

            for index, heat in enumerate(chp_gen_hourly_btuh):
                dem = heat_demand[index]
                if dem < heat:
                    heat_diff = abs(heat - dem)
                    excess_heat.append(heat_diff)
                elif heat <= dem:
                    heat_diff = -1 * abs(dem - heat)
                    excess_heat.append(heat_diff)
                else:
                    raise Exception('Error in thermal_storage module function: calc_excess_heat')
            return excess_heat


def calc_tes_heat_flow_and_soc(chp_gen_hourly_btuh=None, tes_size=None, load_following_type=None, class_dict=None):
    """
    Adds or subtracts heat from storage based on excess heat generated by
    CHP or demand gaps not met by CHP (according to calc_excess_and_deficit_chp_heat_gen
    function).

    Used in the aux_boiler.py function, calc_aux_boiler_output_rate

    Parameters
    ---------
    tes_size: Quantity
        contains size of thermal storage in units of Btu.
    chp_gen_hourly_btuh: list
        contains hourly chp heat generated in Btu/hr.
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py)
    load_following_type: string
        specifies whether calculation is for electrical load following (ELF) state
        or thermal load following (TLF) state.

    Returns
    -------
    tes_heat_rate_list_btuh: list (Quantity)
        Storage heat rate for each hour. Values are positive for heat added and
        negative for heat discharged.Units are Btu/hr
    soc_list: list (Quantity, dimensionless)
        Hourly status of TES storage. Values are 0 for empty and 1 for full. Calculated by
        dividing current_status by the TES capacity.
    """
    args_list = [chp_gen_hourly_btuh, tes_size, load_following_type, class_dict]
    if any(elem is None for elem in args_list) is False:
        # Exit function if TES is not recommended
        if tes_size.magnitude == 0:
            zero_rate_list = []
            zero_soc_list = []
            list_size = len(class_dict['demand'].hl)
            zero_rate_item = Q_(0, ureg.Btu / ureg.hour)
            zero_soc_item = Q_(0, '')
            for index in range(list_size):
                zero_rate_list.append(zero_rate_item)
                zero_soc_list.append(zero_soc_item)
            return zero_rate_list, zero_soc_list

        # Negative values indicate CHP gen is less than demand (TES needs to discharge)
        excess_and_deficit = calc_excess_and_deficit_chp_heat_gen(chp_gen_hourly_btuh=chp_gen_hourly_btuh,
                                                                  load_following_type=load_following_type,
                                                                  class_dict=class_dict)
        tes_heat_rate_list_btuh = []
        soc_list = []
        current_status_btu = class_dict['tes'].start * tes_size

        for index in range(len(excess_and_deficit)):
            excess_or_deficit_btuh = excess_and_deficit[index]
            excess_or_deficit_btu = (excess_or_deficit_btuh * Q_(1 * ureg.hour)).to(ureg.Btu)
            new_status_btu = excess_or_deficit_btu + current_status_btu
            # If demand is met exactly by CHP
            if excess_or_deficit_btuh == 0:
                storage_rate = Q_(0, ureg.Btu / ureg.hour)
                tes_heat_rate_list_btuh.append(storage_rate)
                soc_list.append(current_status_btu/tes_size)
                current_status_btu = new_status_btu
            # If CHP is over-generating and TES has room for heat
            elif 0 < excess_or_deficit_btuh and new_status_btu <= tes_size:
                storage_rate = excess_or_deficit_btuh
                tes_heat_rate_list_btuh.append(storage_rate)
                soc_list.append(current_status_btu/tes_size)
                current_status_btu = new_status_btu
            # If CHP is over-generating and excess heat would over-fill TES
            elif 0 < excess_or_deficit_btuh and tes_size < new_status_btu:
                storage_rate = (tes_size - current_status_btu) / Q_(1, ureg.hour)
                storage_rate.ito(ureg.Btu / ureg.hour)
                tes_heat_rate_list_btuh.append(storage_rate)
                soc_list.append(current_status_btu/tes_size)
                current_status_btu = tes_size
            # If heat is needed and dispatching heat would not empty TES
            elif excess_or_deficit_btu < 0 < new_status_btu:
                storage_rate = excess_or_deficit_btuh
                tes_heat_rate_list_btuh.append(storage_rate)
                soc_list.append(current_status_btu/tes_size)
                current_status_btu = new_status_btu
            # If heat is needed and dispatching heat WOULD empty TES
            elif excess_or_deficit_btuh < 0 and new_status_btu <= 0:
                storage_rate = -1 * current_status_btu / Q_(1, ureg.hours)
                storage_rate.ito(ureg.Btu / ureg.hours)
                tes_heat_rate_list_btuh.append(storage_rate)
                soc_list.append(Q_(0, ''))
                current_status_btu = Q_(0, ureg.Btu)
            else:
                raise Exception("Error in tes_heat_stored function")

        return tes_heat_rate_list_btuh, soc_list
