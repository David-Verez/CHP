"""
Module Description:
    Contains functions needed to calculate the thermal energy stored and thermal
    energy dispatched by the thermal energy storage (TES) system
"""

from lfd_package.modules import chp as cogen, sizing_calcs as sizing
from lfd_package.modules.__init__ import ureg, Q_


def calc_excess_and_deficit_chp_heat_gen(chp_gen_hourly_kwh_dict=None, load_following_type=None, class_dict=None):
    """
    Calculates excess heat generated by the CHP unit each hour (positive values) and
    the difference between the heat generated by the CHP unit and the heat needed
    to meet demand (negative values).

    Function is used in the calc_tes_heat_flow_and_soc function

    Parameters
    ---------
    ab: AuxBoiler Class
        contains initialized class data using CLI inputs (see command_line.py)
    chp: CHP Class
        contains initialized class data using CLI inputs (see command_line.py)
    demand: EnergyDemand Class
        contains initialized class data using CLI inputs (see command_line.py)
    load_following_type: string
        specifies whether calculation is for electrical load following (ELF) state
        or thermal load following (TLF) state.

    Returns
    -------
    excess_heat: list (Quantity)
        Excess heat generated by CHP each hour (positive) and additional heat needed
        (negative). All items have units of Btu/hour.
    """
    args_list = [chp_gen_hourly_kwh_dict, load_following_type, class_dict]
    if any(elem is None for elem in args_list) is False:
        heat_demand = class_dict['demand'].hl
        if load_following_type is "PP":
            chp_heat_gen_hourly = cogen.pp_calc_hourly_heat_generated(chp_gen_hourly_kwh=chp_gen_hourly_kwh_dict["PP"],
                                                                      class_dict=class_dict)
        elif load_following_type is "ELF":
            chp_heat_gen_hourly = cogen.elf_calc_hourly_heat_generated(chp_gen_hourly_kwh=chp_gen_hourly_kwh_dict["ELF"],
                                                                       class_dict=class_dict)
        elif load_following_type is "TLF":
            raise Exception("Use tlf_calc_hourly_heat_generated function from chp.py")  # TODO: Fix this
        else:
            raise Exception("Error passing load_following_type to thermal_storage.py function, "
                            "calc_excess_and_deficit_heat")

        excess_heat = []

        for index, heat in enumerate(chp_heat_gen_hourly):
            dem = heat_demand[index]
            if dem < heat:
                heat_diff = abs(heat - dem)
                excess_heat.append(heat_diff)
            elif heat <= dem:
                heat_diff = -1 * abs(dem - heat)
                excess_heat.append(heat_diff)
            else:
                raise Exception('Error in thermal_storage module function: calc_excess_heat')
        return excess_heat


def calc_tes_heat_flow_and_soc(chp_gen_hourly_kwh_dict=None, tes_size=None, load_following_type=None, class_dict=None):
    """
    Adds or subtracts heat from storage based on excess heat generated by
    CHP or demand gaps not met by CHP (according to calc_excess_and_deficit_chp_heat_gen
    function).

    Used in the aux_boiler.py function, calc_aux_boiler_output_rate

    Parameters
    ---------
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py)
    load_following_type: string
        specifies whether calculation is for electrical load following (ELF) state
        or thermal load following (TLF) state.

    Returns
    -------
    tes_heat_rate_list_btu_hour: list (Quantity)
        Storage heat rate for each hour. Values are positive for heat added and
        negative for heat discharged.Units are Btu/hr
    soc_list: list (Quantity, dimensionless)
        Hourly status of TES storage. Values are 0 for empty and 1 for full. Calculated by
        dividing current_status by the TES capacity.
    """
    args_list = [chp_gen_hourly_kwh_dict, tes_size, load_following_type, class_dict]
    if any(elem is None for elem in args_list) is False:
        # Exit function if TES is not recommended
        if tes_size.magnitude == 0:
            zero_rate_list = []
            zero_soc_list = []
            list_size = len(class_dict['demand'].hl)
            zero_rate_item = Q_(0, ureg.Btu / ureg.hour)
            zero_soc_item = Q_(0, '')
            for index in range(list_size):
                zero_rate_list.append(zero_rate_item)
                zero_soc_list.append(zero_soc_item)
            return zero_rate_list, zero_soc_list

        excess_and_deficit = calc_excess_and_deficit_chp_heat_gen(chp_gen_hourly_kwh_dict=chp_gen_hourly_kwh_dict,
                                                                  load_following_type=load_following_type,
                                                                  class_dict=class_dict)
        tes_heat_rate_list_btu_hour = []
        soc_list = []
        current_status = class_dict['tes'].start * tes_size

        for index, heat_rate in enumerate(excess_and_deficit):
            new_status = (heat_rate * 1 * ureg.hour) + current_status
            if heat_rate == 0:
                stored_heat = Q_(0, ureg.Btu / ureg.hour)
                tes_heat_rate_list_btu_hour.append(stored_heat)
                soc_list.append(current_status/tes_size)
            elif 0 < heat_rate and new_status <= tes_size:
                stored_heat = heat_rate
                tes_heat_rate_list_btu_hour.append(stored_heat)
                current_status = new_status
                soc_list.append(current_status/tes_size)
            elif 0 < heat_rate and tes_size < new_status:
                diff = (new_status - tes_size) / (1 * ureg.hour)
                stored_heat = heat_rate - diff
                tes_heat_rate_list_btu_hour.append(stored_heat)
                current_status = tes_size
                soc_list.append(current_status/tes_size)
            elif (heat_rate * 1 * ureg.hour) < 0 <= new_status:
                stored_heat = heat_rate
                tes_heat_rate_list_btu_hour.append(stored_heat)
                current_status = new_status
                soc_list.append(current_status/tes_size)
            elif heat_rate < 0 and new_status < 0:
                diff = new_status / (1 * ureg.hour)
                stored_heat = abs(heat_rate - diff)
                tes_heat_rate_list_btu_hour.append(stored_heat)
                current_status = Q_(0, ureg.Btu)
                soc_list.append(current_status/tes_size)
            else:
                raise Exception("Error in tes_heat_stored function")

        return tes_heat_rate_list_btu_hour, soc_list
