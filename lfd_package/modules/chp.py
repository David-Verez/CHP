"""
Module Description:
    Contains functions needed to calculate the demand, electricity cost, and fuel use of
    the micro-chp unit for both electrical load following (ELF) and thermal load following
    (TLF) cases. Also accounts for whether net metering is permitted by the local utility.
"""

import math
from lfd_package.modules import sizing_calcs as sizing
from lfd_package.modules.__init__ import ureg, Q_


def calc_hourly_fuel_use(chp_size=None, class_dict=None, chp_electric_gen_hourly_kwh=None):
    """
    Uses sizing.electrical_output_to_fuel_consumption() to calculate hourly fuel use.

    Used in the command_line.py module

    Parameters
    ---------
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py)
    chp_size: Quantity
        contains size of CHP in units of kW.
    chp_electric_gen_hourly_kwh: list
        contains lists of hourly chp electricity generated in kWh.

    Returns
    -------
    fuel_use_btu_list: list
        Annual, hourly fuel use in units of Btu.
    """
    args_list = [chp_size, chp_electric_gen_hourly_kwh, class_dict]
    if any(elem is None for elem in args_list) is False:
        fuel_use_btu_list = []

        # Calculate fuel use
        for index, el in enumerate(chp_electric_gen_hourly_kwh):
            chp_hourly_electric_kw = (el / Q_(1, ureg.hours)).to(ureg.kW)
            fuel_use_hourly_kw = sizing.electrical_output_to_fuel_consumption(chp_hourly_electric_kw)
            fuel_use_hourly_btu = (fuel_use_hourly_kw * Q_(1, ureg.hours)).to(ureg.Btu)
            fuel_use_btu_list.append(fuel_use_hourly_btu)

        return fuel_use_btu_list


def calc_electricity_bought(chp_gen_hourly_kwh=None, chp_size=None, class_dict=None):
    """
    Calculates electricity bought as difference between chp gen and demand.

    Parameters
    ----------
    chp_gen_hourly_kwh: list
        contains lists of hourly chp electricity generated in kWh.
    chp_size: Quantity
        contains size of CHP in units of kW.
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py)

    Returns
    -------
    bought_kwh_list: list
        contains hourly electricity bought in kWh.
    """
    args_list = [chp_gen_hourly_kwh, chp_size, class_dict]
    if any(elem is None for elem in args_list) is False:

        bought_kwh_list = []

        for index, dem_kw in enumerate(class_dict['demand'].el):
            dem_kwh = (dem_kw * Q_(1, ureg.hours)).to(ureg.kWh)
            gen_kwh = chp_gen_hourly_kwh[index]

            if gen_kwh < dem_kwh:
                bought = dem_kwh - gen_kwh
                bought_kwh_list.append(bought)
            else:
                bought = Q_(0, ureg.kWh)
                bought_kwh_list.append(bought)

        return bought_kwh_list


"""
Power Purchase (PP) Functions
"""


def pp_calc_electricity_gen_sold(chp_size=None, class_dict=None):
    """
    Calculates electricity generated by CHP and sold to grid each hour.
    Units are kWh for both.

    Parameters
    ----------
    chp_size: Quantity
        contains size of CHP in units of kW.
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py)

    Returns
    -------
    chp_gen_kwh_list: list
        contains electricity generated hourly by CHP in units of kWh.
    chp_sold_kwh_list: list
        contains excess electricity generated hourly by CHP and sold to grid.
        Units are in kWh.
    """
    args_list = [chp_size, class_dict]
    if any(elem is None for elem in args_list) is False:

        chp_hourly_kwh = (chp_size * Q_(1, ureg.hours)).to(ureg.kWh)
        chp_min_gen_kw = chp_size * class_dict['chp'].min_pl
        chp_gen_kwh_list = []
        chp_sold_kwh_list = []

        for dem in class_dict['demand'].el:
            dem_kwh = (dem * Q_(1, ureg.hours)).to(ureg.kWh)

            # Electricity gen and sold calcs
            if chp_min_gen_kw <= dem <= chp_size:
                chp_gen_kwh_list.append(chp_hourly_kwh)
                chp_sold_kwh_list.append(chp_hourly_kwh - dem_kwh)
            elif dem < chp_min_gen_kw:
                chp_gen_kwh_list.append(Q_(0, ureg.kWh))
                chp_sold_kwh_list.append(Q_(0, ureg.kWh))
            else:
                raise Exception("CHP not sized to peak electrical demand")

        return chp_gen_kwh_list, chp_sold_kwh_list


def pp_calc_hourly_heat_generated(chp_gen_hourly_kwh=None, class_dict=None):
    """
    Calculates hourly heat generated by CHP for Power Purchase operation.

    Parameters
    ----------
    chp_gen_hourly_kwh: list
        contains electricity generated hourly by CHP in units of kWh.
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py)

    Returns
    -------
    hourly_heat_rate: list
        contains hourly thermal energy generated by CHP. Units are Btu/hr.
    """
    args_list = [chp_gen_hourly_kwh, class_dict]
    if any(elem is None for elem in args_list) is False:
        hourly_heat_rate = []

        for i, el_gen_kwh in enumerate(chp_gen_hourly_kwh):
            el_gen = (el_gen_kwh / Q_(1, ureg.hours)).to(ureg.kW)
            heat_kw = sizing.electrical_output_to_thermal_output(el_gen)
            heat = heat_kw.to(ureg.Btu / ureg.hour)
            hourly_heat_rate.append(heat)

        return hourly_heat_rate


"""
ELF Functions
"""


def elf_calc_electricity_generated(chp_size=None, class_dict=None):
    """
    Calculates the electricity generated by the chp system.

    This function compares max and min CHP capacity with the hourly electrical
    demand of the building. If demand is above the max or below the min, it calculates
    electricity generated by the CHP unit each hour.

    Used in the elf_calc_hourly_heat_generated, calc_avg_efficiency,
    calc_annual_fuel_use_and_costs, and calc_annual_electric_cost functions

    Parameters
    ---------
    chp_size: Quantity
        contains size of CHP in units of kW.
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py).

    Returns
    -------
    chp_gen_kwh_list: list
        contains Quantity float values for electricity generated hourly in units of kWh.
    """
    args_list = [chp_size, class_dict]
    if any(elem is None for elem in args_list) is False:
        chp_gen_kwh_list = []

        chp_min_output = (class_dict['chp'].min_pl * chp_size).to(ureg.kW)

        for dem in class_dict['demand'].el:
            # Verifies acceptable input value range
            assert dem.magnitude >= 0
            dem_kw = dem.to(ureg.kW)

            if chp_min_output <= dem_kw <= chp_size:
                gen = (dem_kw * Q_(1, ureg.hour)).to(ureg.kWh)
                chp_gen_kwh_list.append(gen)
            elif dem_kw < chp_min_output:
                gen = Q_(0, ureg.kWh)
                chp_gen_kwh_list.append(gen)
            elif chp_size < dem_kw:
                gen = (chp_size * Q_(1, ureg.hour)).to(ureg.kWh)
                chp_gen_kwh_list.append(gen)
            else:
                raise Exception("Error in ELF calc_utility_electricity_needed function")

        return chp_gen_kwh_list


def elf_calc_hourly_heat_generated(chp_gen_hourly_kwh=None, class_dict=None):
    """
    Uses the hourly electricity generated by CHP as input for
    sizing.electrical_output_to_thermal_output() to calculate the
    hourly thermal output of the CHP unit. Assumes electrical load
    following (ELF) operation.

    Used in the thermal_storage module: calc_excess_and_deficit_heat function

    Parameters
    ---------
    chp_gen_hourly_kwh: list
        contains CHP electricity generated hourly in units of kWh.
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py).

    Returns
    -------
    hourly_heat_rate: list
        Contains Quantity float values for hourly thermal output of the CHP unit
        in units of Btu/hour
    """
    args_list = [chp_gen_hourly_kwh, class_dict]
    if any(elem is None for elem in args_list) is False:
        hourly_heat_rate = []

        for i, el_gen_kwh in enumerate(chp_gen_hourly_kwh):
            el_gen = (el_gen_kwh / Q_(1, ureg.hours)).to(ureg.kW)
            heat_kw = sizing.electrical_output_to_thermal_output(el_gen)
            heat = heat_kw.to(ureg.Btu / ureg.hour)
            hourly_heat_rate.append(heat)

        return hourly_heat_rate


"""
TLF Functions
"""


def tlf_calc_hourly_heat_chp_tes_soc(chp_size=None, tes_size=None, class_dict=None):
    """
    Calculates the hourly CHP heat generated, hourly TES heat rate, and TES
    SOC status each hour.

    This function compares the thermal demand of the building with the max and
    min heat that can be generated by the chp system. If TES needs heat and CHP
    covers demand, CHP runs at full power and puts excess in TES. If demand is less
    than CHP min, TES dispatches heat. If TES is empty and demand is less than CHP
    min, CHP runs at full power. If demand is above CHP max, TES is dispatched.
    Assumes the load following state is thermal load following (TLF).

    Used in the thermal_storage module: calc_excess_and_deficit_heat function

    Parameters
    ----------
    tes_size: Quantity
        contains size of TES in units of Btu.
    chp_size: Quantity
        contains size of CHP in units of kW.
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py).

    Returns
    -------
    chp_hourly_heat_rate_list: list
        contains Quantity float values for hourly heat generated by the CHP
        system in units of Btu/hour.
    tes_heat_rate_list_btu_hour: list
        contains Quantities for hourly TES thermal dispatch or charging.
        Discharging is negative while charging is positive. Units are Btu/hr.
    soc_list: list
        contains dimensionless Quantity float values representing percent charge
        of thermal storage for each hour.

    """
    args_list = [chp_size, tes_size, class_dict]
    if any(elem is None for elem in args_list) is False:
        chp_min_output = (class_dict['chp'].min_pl * chp_size).to(ureg.kW)

        chp_hourly_heat_rate_list = []
        chp_heat_rate_min = (sizing.electrical_output_to_thermal_output(chp_min_output)).to(ureg.Btu / ureg.hour)
        chp_heat_rate_cap = sizing.electrical_output_to_thermal_output(chp_size).to(ureg.Btu / ureg.hour)

        tes_heat_rate_list_btu_hour = []
        soc_list = []

        for i, dem in enumerate(class_dict['demand'].hl):
            # Verifies acceptable input value range
            assert dem.magnitude >= 0
            if i == 0:
                current_status = class_dict['tes'].start * tes_size

            if chp_heat_rate_min <= dem <= chp_heat_rate_cap and tes_size == current_status:
                # If TES is full and chp meets demand, follow thermal load
                gen = dem.to(ureg.Btu / ureg.hour)
                chp_hourly_heat_rate_list.append(gen)

                # Handle condition of TES size being zero
                if math.isclose(tes_size.magnitude, 0):
                    tes_heat_rate_list_btu_hour.append(Q_(0, ureg.Btu / ureg.hours))
                    soc_list.append(Q_(0, ''))
                else:
                    stored_heat = Q_(0, ureg.Btu / ureg.hour)
                    tes_heat_rate_list_btu_hour.append(stored_heat)
                    new_status = (stored_heat * Q_(1, ureg.hour)) + current_status
                    soc_list.append(new_status / tes_size)
                    current_status = new_status
            elif chp_heat_rate_min <= dem <= chp_heat_rate_cap and current_status < tes_size:
                # If TES needs heat and chp meets demand, run CHP at full power and put excess in TES
                gen = chp_heat_rate_cap
                chp_hourly_heat_rate_list.append(gen)

                # Handle condition of TES size being zero
                if math.isclose(tes_size.magnitude, 0):
                    tes_heat_rate_list_btu_hour.append(Q_(0, ureg.Btu / ureg.hours))
                    soc_list.append(Q_(0, ''))
                else:
                    # Make sure SOC does not exceed 1 when heat is added
                    soc_check = ((current_status / Q_(1, ureg.hours)) + gen - dem) / (tes_size / Q_(1, ureg.hours))
                    if soc_check.magnitude < 1:
                        stored_heat = gen - dem
                        assert stored_heat >= 0
                    else:
                        stored_heat = (tes_size - current_status) / Q_(1, ureg.hours)
                        assert stored_heat >= 0
                    tes_heat_rate_list_btu_hour.append(stored_heat)
                    new_status = (stored_heat * Q_(1, ureg.hours)) + current_status
                    soc_list.append(new_status / tes_size)
                    current_status = new_status
            elif dem < chp_heat_rate_min and dem <= (current_status / Q_(1, ureg.hours)):
                # If TES not empty, then let out heat to meet demand
                gen = Q_(0, ureg.Btu / ureg.hour)
                chp_hourly_heat_rate_list.append(gen)

                # Handle condition of TES size being zero
                if math.isclose(tes_size.magnitude, 0):
                    tes_heat_rate_list_btu_hour.append(Q_(0, ureg.Btu / ureg.hours))
                    soc_list.append(Q_(0, ''))
                else:
                    discharged_heat = gen - dem     # Should be negative
                    assert discharged_heat <= 0
                    tes_heat_rate_list_btu_hour.append(discharged_heat)
                    new_status = (discharged_heat * Q_(1, ureg.hours)) + current_status
                    soc_list.append(new_status / tes_size)
                    current_status = new_status
            elif chp_heat_rate_min > dem > (current_status / Q_(1, ureg.hours)):
                # If TES is empty (or does not have enough to meet demand), then run CHP at full power
                gen = chp_heat_rate_cap
                chp_hourly_heat_rate_list.append(gen)

                # Handle condition of TES size being zero
                if math.isclose(tes_size.magnitude, 0):
                    tes_heat_rate_list_btu_hour.append(Q_(0, ureg.Btu / ureg.hours))
                    soc_list.append(Q_(0, ''))
                else:
                    soc_check = ((current_status / Q_(1, ureg.hours)) + gen - dem) / (tes_size / Q_(1, ureg.hours))
                    if soc_check >= 1:
                        stored_heat = (tes_size - current_status) / Q_(1, ureg.hours)
                        assert stored_heat >= 0
                    else:
                        stored_heat = gen - dem
                        assert stored_heat >= 0

                    new_status = (stored_heat * Q_(1, ureg.hour)) + current_status
                    tes_heat_rate_list_btu_hour.append(stored_heat)
                    soc_list.append(new_status / tes_size)
                    current_status = new_status
            elif chp_heat_rate_cap < dem < (current_status / Q_(1, ureg.hours)):
                # If demand exceeds CHP generation, use TES
                gen = chp_heat_rate_cap
                chp_hourly_heat_rate_list.append(gen)

                # Handle condition of TES size being zero
                if math.isclose(tes_size.magnitude, 0):
                    tes_heat_rate_list_btu_hour.append(Q_(0, ureg.Btu / ureg.hours))
                    soc_list.append(Q_(0, ''))
                else:
                    soc_check = ((current_status / Q_(1, ureg.hours)) + gen - dem) / (tes_size / Q_(1, ureg.hours))
                    if soc_check <= 0:
                        discharged_heat = -1 * current_status / Q_(1, ureg.hours)
                        assert discharged_heat <= 0
                    else:
                        discharged_heat = gen - dem     # Should be negative
                        assert discharged_heat <= 0

                    tes_heat_rate_list_btu_hour.append(discharged_heat)
                    new_status = (discharged_heat * Q_(1, ureg.hour)) + current_status
                    soc_list.append(new_status / tes_size)
                    current_status = new_status
            elif chp_heat_rate_cap < dem and (current_status / Q_(1, ureg.hours)) < dem:
                # Discharge everything from TES
                gen = chp_heat_rate_cap
                chp_hourly_heat_rate_list.append(gen)

                # Handle condition of TES size being zero
                if math.isclose(tes_size.magnitude, 0):
                    tes_heat_rate_list_btu_hour.append(Q_(0, ureg.Btu / ureg.hours))
                    soc_list.append(Q_(0, ''))
                else:
                    discharged_heat = -1 * current_status / Q_(1, ureg.hours)  # Should be negative
                    assert discharged_heat <= 0
                    tes_heat_rate_list_btu_hour.append(discharged_heat)
                    new_status = (discharged_heat * Q_(1, ureg.hours)) + current_status
                    soc_list.append(new_status / tes_size)
                    current_status = new_status
            else:
                raise Exception("Error in TLF calc_utility_electricity_needed function")

        return chp_hourly_heat_rate_list, tes_heat_rate_list_btu_hour, soc_list


def tlf_calc_electricity_generated(chp_gen_hourly_btuh=None, class_dict=None):
    """
    Calculates the electricity generated by the CHP system.

    For hourly heat generated by CHP, this function calculates the associated electrical
    output using sizing.thermal_output_to_electrical_output().

    Parameters
    ----------
    chp_gen_hourly_btuh: list
        contains lists of hourly chp heat generated in Btu/hr.
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py).

    Returns
    -------
    hourly_electricity_gen: list
        contains Quantity float values for CHP electricity generated each hour in
        units of kWh
    """
    args_list = [chp_gen_hourly_btuh, class_dict]
    if any(elem is None for elem in args_list) is False:
        hourly_electricity_gen = []

        for i, hourly_heat_rate in enumerate(chp_gen_hourly_btuh):
            heat_gen_kw = hourly_heat_rate.to(ureg.kW)
            electric_gen_kwh = (sizing.thermal_output_to_electrical_output(heat_gen_kw) * Q_(1, ureg.hour)).to(ureg.kWh)
            hourly_electricity_gen.append(electric_gen_kwh)

        return hourly_electricity_gen


def tlf_calc_electricity_sold(chp_gen_hourly_kwh=None, class_dict=None):
    """

    Parameters
    ----------
    chp_gen_hourly_kwh: list
        contains CHP electricity generated hourly in units of kWh.
    class_dict: dict
        contains initialized class data using CLI inputs (see command_line.py).

    Returns
    -------
    sold_kwh_list: list
        contains hourly electricity sold to the grid in units of kWh.
    """
    args_list = [chp_gen_hourly_kwh, class_dict]
    if any(elem is None for elem in args_list) is False:
        dem_el_list = class_dict['demand'].el
        sold_kwh_list = []

        for index, dem in enumerate(dem_el_list):
            dem_kwh = (dem * Q_(1, ureg.hours)).to(ureg.kWh)
            chp_gen_kwh = chp_gen_hourly_kwh[index]

            # Electricity gen and sold calcs
            if dem_kwh < chp_gen_kwh:
                sold_kwh = chp_gen_kwh - dem_kwh
                sold_kwh_list.append(sold_kwh)
            else:
                sold_kwh = Q_(0, ureg.kWh)
                sold_kwh_list.append(sold_kwh)

        return sold_kwh_list
